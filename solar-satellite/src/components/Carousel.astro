---
interface Props {
  images: string[];
}

const { images } = Astro.props;
// Use Astro.slug or a deterministic ID to avoid hydration mismatches
const id = `carousel-${Astro.slug || Math.random().toString(36).slice(2, 9)}`;
---

<div class="relative w-full max-w-2xl mx-auto group" role="region" aria-label="Image carousel">
  <div 
    id={id}
    class="flex overflow-x-auto gap-4 snap-x snap-mandatory scroll-smooth pb-4 no-scrollbar"
    style="scrollbar-width: none;"
    tabindex="0"
    aria-live="polite"
  >
    {images.map((src, index) => (
      <div 
        class="flex-shrink-0 w-full snap-center relative aspect-video rounded-xl overflow-hidden shadow-lg border border-gray-200 bg-gray-100"
        role="group"
        aria-label={`Slide ${index + 1} of ${images.length}`}
      >
        <img 
          src={src} 
          alt={`Slide ${index + 1}`} 
          class="w-full h-full object-cover"
          loading="lazy"
        />
        <div class="absolute bottom-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded">
          {index + 1} / {images.length}
        </div>
      </div>
    ))}
  </div>

  <button 
    data-target={id} 
    data-action="prev" 
    class="carousel-btn absolute left-2 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white text-gray-800 p-2 rounded-full shadow-lg opacity-0 group-hover:opacity-100 transition-opacity disabled:opacity-30 disabled:cursor-not-allowed"
    aria-label="Previous slide"
  >
    ←
  </button>
  <button 
    data-target={id} 
    data-action="next" 
    class="carousel-btn absolute right-2 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white text-gray-800 p-2 rounded-full shadow-lg opacity-0 group-hover:opacity-100 transition-opacity disabled:opacity-30 disabled:cursor-not-allowed"
    aria-label="Next slide"
  >
    →
  </button>
</div>

<script define:vars={{ carouselId: id }}>
  // Scoped to this specific carousel instance
  const track = document.getElementById(carouselId);
  if (!track) return;

  const prevBtn = document.querySelector(`[data-target="${carouselId}"][data-action="prev"]`);
  const nextBtn = document.querySelector(`[data-target="${carouselId}"][data-action="next"]`);

  if (!prevBtn || !nextBtn || !(prevBtn instanceof HTMLButtonElement) || !(nextBtn instanceof HTMLButtonElement)) return;

  function updateButtonStates() {
    const { scrollLeft, scrollWidth, clientWidth } = track;
    const isAtStart = scrollLeft <= 0;
    const isAtEnd = scrollLeft >= scrollWidth - clientWidth - 1;
    
    prevBtn.disabled = isAtStart;
    nextBtn.disabled = isAtEnd;
  }

  function scrollCarousel(direction) {
    const scrollAmount = track.clientWidth;
    track.scrollBy({ 
      left: direction === 'next' ? scrollAmount : -scrollAmount, 
      behavior: 'smooth' 
    });
  }

  // Button click handlers
  prevBtn.addEventListener('click', () => scrollCarousel('prev'));
  nextBtn.addEventListener('click', () => scrollCarousel('next'));

  // Keyboard navigation
  track.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      scrollCarousel('prev');
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      scrollCarousel('next');
    } else if (e.key === 'Home') {
      e.preventDefault();
      track.scrollTo({ left: 0, behavior: 'smooth' });
    } else if (e.key === 'End') {
      e.preventDefault();
      track.scrollTo({ left: track.scrollWidth, behavior: 'smooth' });
    }
  });

  // Update button states on scroll
  track.addEventListener('scroll', updateButtonStates);
  
  // Initial state
  updateButtonStates();

  // Handle View Transitions
  document.addEventListener('astro:page-load', () => {
    // Re-query elements in case DOM was replaced
    const newTrack = document.getElementById(carouselId);
    if (newTrack && newTrack !== track) {
      // Re-setup if needed
      updateButtonStates();
    }
  });
</script>